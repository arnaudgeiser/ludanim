(ns ludexploit-cj.handler
  (:require [compojure.core :refer :all]
            [compojure.route :as route]
            [clojure.java.io :refer :all]
            [clojure.set :refer :all]
            [ring.middleware.json :refer [wrap-json-body wrap-json-response]]
            [ring.middleware.basic-authentication :refer [wrap-basic-authentication]]
            [ring.middleware.cors :refer [wrap-cors]]
            [ludexploit-cj.printing :as p]
            [ludexploit-cj.data-access :refer :all]
            [ludexploit-cj.email :as email]
            [ludexploit-cj.config :refer :all]
            [cheshire.generate :refer [add-encoder]]
            [cheshire.core :refer [generate-string]]
            [ring.middleware.defaults :refer [wrap-defaults site-defaults api-defaults]]
            [clj-time.core :as t]
            [clj-time.format :as f]
            [clj-time.coerce :as c]
            [crypto.password.bcrypt :refer [encrypt check]]))

(def date-formatter
  (f/formatter "dd-MM-yyyy"))

(defn to-sql-date [date] (c/to-sql-date (f/parse date-formatter date)))

(add-encoder org.joda.time.DateTime
    (fn [c jsonGenerator]
      (.writeString jsonGenerator (f/unparse date-formatter c))))

(defn filter-inscriptions [events]
  (filter #(and (:hasinscriptions %) (< (:ticket_spaces %) 100)) events))

  (defn emails-from-event [event]
    (for [r (:reservations event)
    :let [address (:user_email r)]
    :when (not (nil? address))]
      address))

(defn emails [events]
  (flatten (map #(emails-from-event %) events)))

(defn send-message [req]
  (let [idEvent (get-in req [:route-params :idEvent])
        email (:body req)
        event (search-event idEvent)
        adresses (emails event)
        email-to-send (assoc email :to adresses)]
          (if (seq? adresses) (do (email/send-message email-to-send) event))))

(defn create-and-get-reservation [req]
  (let [data (assoc (:body req) :event_id (get-in req [:route-params :idEvent]))]
    (do
      (create-reservation data)
      (search-event (:event_id data)))))

(defn search-events-by-day [events day]
  (prn day)
  (for [e events
        :let [start-date (c/from-sql-date (:event_start_date e))]
        :when (= (t/day-of-week start-date) (Integer/parseInt day))]
        e))

(defroutes app-routes
  (GET "/festivals/:idFestival/events" [idFestival] (sort-by :event_name (search-events-by-festival idFestival)))
  (GET "/events" [] (search-events))
  (GET "/events/:idEvent" [idEvent] (search-event idEvent))
  (GET "/events/:idEvent/emails" [idEvent] (emails (search-event idEvent)))
  (PUT "/events/:idEvent/send" req (generate-string (first (send-message req))))
  (GET "/events/:idEvent/raw" [idEvent] (generate-string (search-event-raw idEvent)))
  (POST "/events/:idEvent/reservations" req (generate-string (first (create-and-get-reservation req))))
  (POST "/login" [] "true")
  (DELETE "/reservations/:idReservation" [idReservation] (do (delete-reservation idReservation)) {})
  (POST "/reservations" req (create-reservation (:body req)))

  (GET "/emails" [] (emails (search-events)))
  (GET "/args" [] (System/getProperty "AS"))
  (GET "/edn" [] (clojure.edn/read-string (slurp "/home/geiser/config.edn")))
  (GET "/sendemail" [params] ((do (prn params) (send-message))))
  (route/not-found "Not Found"))

(defn authenticated? [name pass]
  (let [users (:users config)
        password (get users name)]
  (if (nil? password) false (check pass password))))

(defroutes util-routes
  (GET "/festivals" [] (search-festivals))
  (GET "/encrypt/:password" [password] (encrypt password))
  (GET "/events/:idEvent/print" [idEvent] (p/print-programme (search-event idEvent)))
  (GET "/festivals/:idFestival/print" [idFestival] (p/print-programme (filter-inscriptions (search-events-by-festival idFestival))))
  (GET "/festivals/bydate/:date/print" [date] (p/print-programme (filter-inscriptions (search-events-by-date (to-sql-date date)))))
  (GET "/festivals/:idFestival/byday/:day/print" [idFestival day] (p/print-programme (filter-inscriptions (search-events-by-day (search-events-by-festival idFestival) day))))
  (GET "/festivals/:idFestival/byday/:day" [idFestival day] (generate-string (search-events-by-day (search-events-by-festival idFestival) day))))

(defn wrap-override-cors [routes]
  (wrap-cors routes :access-control-allow-origin [#".*"] :access-control-allow-methods [:get :put :post :delete] :access-control-allow-credentials "true"))

(defroutes app
  (ANY "*" [] (-> util-routes
    ;(wrap-defaults site-defaults)
    (wrap-override-cors)
    (wrap-json-response)))
  (ANY "*" [] (-> app-routes
    (wrap-defaults (assoc-in site-defaults [:security :anti-forgery] false))
    (wrap-json-body {:keywords? true})
    (wrap-json-response)
    (wrap-basic-authentication authenticated? nil {:body "Access denied"})
    (wrap-override-cors))))
